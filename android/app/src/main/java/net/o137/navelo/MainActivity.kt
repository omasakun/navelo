package net.o137.navelo

import android.annotation.SuppressLint
import android.content.Context
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.slideInHorizontally
import androidx.compose.animation.slideOutHorizontally
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.compositionLocalOf
import androidx.compose.ui.Modifier
import androidx.lifecycle.LifecycleOwner
import androidx.navigation.NavController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.mapbox.common.location.Location
import com.mapbox.navigation.base.options.NavigationOptions
import com.mapbox.navigation.core.MapboxNavigation
import com.mapbox.navigation.core.lifecycle.MapboxNavigationApp
import com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver
import com.mapbox.navigation.core.lifecycle.requireMapboxNavigation
import com.mapbox.navigation.core.trip.session.LocationMatcherResult
import com.mapbox.navigation.core.trip.session.LocationObserver
import com.mapbox.navigation.ui.maps.location.NavigationLocationProvider
import kotlinx.serialization.Serializable
import net.o137.navelo.ui.theme.NaveloTheme

val LocalNavController = compositionLocalOf<NavController> {
  error("No NavController provided")
}

val LocalNavigationGod = compositionLocalOf<NavigationGod> {
  error("No NavigationGod provided")
}

class MainActivity : ComponentActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    // TODO: WindowInsets とかについて理解してから、想定されてる方法で edge to edge を実現する
    // enableEdgeToEdge()

    val navigationGod = NavigationGod(this)

    // TODO: continue to run in background
    // MapboxNavigationApp.attach(this)

    setContent {
      App(navigationGod)
    }
  }
}

@Composable
private fun App(navigationGod: NavigationGod) {
  NaveloTheme {
    Box(
      modifier = Modifier
        .fillMaxSize()
        .background(MaterialTheme.colorScheme.background)
    ) {
      val navController = rememberNavController()

      CompositionLocalProvider(LocalNavController provides navController, LocalNavigationGod provides navigationGod) {
        NavHost(
          navController = navController,
          startDestination = Route.Main,
          enterTransition = { slideInHorizontally(initialOffsetX = { it }) },
          exitTransition = { fadeOut() },
          popEnterTransition = { fadeIn() },
          popExitTransition = { slideOutHorizontally(targetOffsetX = { it }) }
        ) {
          composable<Route.Main> { MainScreen() }
          composable<Route.Navigation> { NavigationScreen() }
          composable<Route.Settings> { SettingsScreen() }
          composable<Route.License> { LicenseScreen() }
        }
      }
    }
  }
}

sealed class Route {
  @Serializable
  object Main

  @Serializable
  object Navigation

  @Serializable
  object Settings

  @Serializable
  object License
}


// TODO: god class
class NavigationGod(private val context: Context) {
  /**
   * [NavigationLocationProvider] is a utility class that helps to provide location updates generated by the Navigation SDK
   * to the Maps SDK in order to update the user location indicator on the map.
   */
  val navigationLocationProvider = NavigationLocationProvider()

  /**
   * Gets notified with location updates.
   *
   * Exposes raw updates coming directly from the location services
   * and the updates enhanced by the Navigation SDK (cleaned up and matched to the road).
   */
  val locationObserver = object : LocationObserver {
    /**
     * Provides the best possible location update, snapped to the route or
     * map-matched to the road if possible.
     */
    override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
      val enhancedLocation = locationMatcherResult.enhancedLocation
      navigationLocationProvider.changePosition(
        enhancedLocation,
        locationMatcherResult.keyPoints,
      )
      Log.i("NavigationGod", "Enhanced location: $enhancedLocation")
    }

    /**
     * Invoked as soon as the [Location] is available.
     */
    override fun onNewRawLocation(rawLocation: Location) {
      Log.i("NavigationGod", "Raw location: $rawLocation")
    }
  }

  val mapboxNavigation: MapboxNavigation by (context as LifecycleOwner).requireMapboxNavigation(
    onInitialize = this::initNavigation,
    onResumedObserver = object : MapboxNavigationObserver {
      @SuppressLint("MissingPermission") // TODO: handle permissions
      override fun onAttached(mapboxNavigation: MapboxNavigation) {
        Log.i("NavigationGod", "MapboxNavigation attached")
//        mapboxNavigation.registerLocationObserver(locationObserver)
//        mapboxNavigation.startTripSession()
      }

      override fun onDetached(mapboxNavigation: MapboxNavigation) {
        Log.i("NavigationGod", "MapboxNavigation detached")
//        mapboxNavigation.unregisterLocationObserver(locationObserver)
      }
    },
  )

  private fun initNavigation() {
    Log.i("NavigationGod", "Initializing navigation")
    MapboxNavigationApp.setup {
      NavigationOptions.Builder(context)
        .build()
    }
  }
}
